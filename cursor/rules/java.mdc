---
description: Enforces best practices for Java development, covering code style, performance, security, and testing. Provides guidelines for writing clean, maintainable, and efficient Java code.
globs: *.java
alwaysApply: false
---
- # Java Best Practices

  This document outlines comprehensive best practices for Java development, covering code organization, common patterns, performance considerations, security, testing, common pitfalls, and tooling. Adhering to these guidelines will help you write clean, maintainable, efficient, and secure Java code.

- ## 1. Code Organization and Structure

  - ### 1.1 File Naming Conventions

    - **Classes and Interfaces:** Use `PascalCase` (e.g., `UserController`, `UserService`)
    - **Methods and Variables:** Use `camelCase` (e.g., `getUserById`, `userName`)
    - **Constants:** Use `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`, `DEFAULT_TIMEOUT`)
    - **Packages:** Use all lowercase (e.g., `com.example.user`)
    - **Avoid abbreviations:** Use meaningful and descriptive names

  - ### 1.2 Module Organization

    - **`module-info.java`:** Use `module-info.java` to define module dependencies and exported packages. This allows for strong encapsulation and controlled access to internal APIs.
    - **Explicit Dependencies:** Declare all module dependencies explicitly in `module-info.java`. Avoid relying on transitive dependencies.
    - **Minimize Exports:** Only export the packages that are intended for public use. Keep internal packages hidden from other modules.

  - ### 1.3 Component Architecture

    - **Dependency Injection:** Use dependency injection (DI) to manage component dependencies. Frameworks like Spring and Guice simplify DI.
    - **Inversion of Control (IoC):** Apply IoC to decouple components and improve testability.
    - **Layered Architecture:** Structure your application into layers (e.g., presentation, business logic, data access). This promotes separation of concerns and maintainability.
    - **Microservices:** For large, complex applications, consider a microservices architecture. This allows for independent development, deployment, and scaling of individual services.

  - ### 1.4 Code Clarity and Conciseness

    - **Method Length:**
      - Keep methods under 20 lines of code
      - If a method grows larger, consider extracting logical chunks into helper methods
      - Single Responsibility: Each method should do exactly one thing

    - **Parameter Count:**
      - Limit method parameters to 4 or fewer
      - Use builder pattern or parameter objects for methods requiring more parameters
      - Consider breaking down the method if it needs too many parameters

    - **Return Types:**
      - Prefer Optional<T> over null returns for optional values
      - Return empty collections instead of null
      - Use specific types over generic Object returns

    - **Variable Naming:**
      - Use intention-revealing names (e.g., `userRepository` not `repo`)
      - Avoid single-letter variables (except in loops or lambdas)
      - Include units in variable names when relevant (e.g., `timeoutInSeconds`)

    - **Code Structure:**
      - One level of abstraction per method
      - Maximum nesting depth of 3 levels
      - Avoid else clauses when possible, prefer early returns
      - Keep line length under 120 characters

    - **Java Features:**
      - Use Stream API for collection transformations when it improves readability
      - Prefer method references over lambdas when possible
      - Use enhanced for loops over traditional for loops
      - Use switch expressions (Java 14+) over switch statements when applicable

    - **Comments and Documentation:**
      - Write self-documenting code
      - Only comment the "why", not the "what"
      - Keep method-level documentation concise and focused on contract
      - Document exceptions and edge cases

    - **Null Handling:**
      - Use @NonNull and @Nullable annotations
      - Validate parameters early in methods
      - Prefer Optional over null for optional values
      - Use Objects.requireNonNull for mandatory parameters

- ## 2. Common Patterns and Anti-patterns

  - ### 2.1 Design Patterns

    - **Singleton:** Use the Singleton pattern only when:
      - Global state is absolutely required (e.g., app configuration)
      - Resource sharing must be strictly controlled (e.g., connection pools)
      - The single instance is guaranteed by the framework (e.g., Spring beans)
      In all other cases, prefer dependency injection.
    - **Factory:** Use the Factory pattern to create objects without specifying their concrete classes. This promotes loose coupling and allows for easy substitution of different implementations.
    - **Strategy:** Use the Strategy pattern to encapsulate different algorithms or behaviors. This allows you to switch between algorithms at runtime.
    - **Observer:** Use the Observer pattern to define a one-to-many dependency between objects. This allows for loose coupling and easy addition of new observers.
    - **Template Method:** Use the Template Method pattern to define the skeleton of an algorithm in a base class, allowing subclasses to override specific steps without changing the overall structure.
    - **Builder:** Use the Builder pattern to construct complex objects with many optional parameters. This improves readability and reduces the risk of errors.

  - ### 2.2 Recommended Approaches

    - **Resource Management:** Always use try-with-resources to ensure proper resource management (e.g., closing streams, connections). This prevents resource leaks.
      java
      try (FileInputStream fis = new FileInputStream("file.txt")) {
          // Use the file input stream
      }

    - **String Concatenation:** Use `StringBuilder` or `StringBuffer` for string concatenation, especially in loops. Avoid using the `+` operator for repeated string concatenation.
      java
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < 100; i++) {
          sb.append(i);
      }
      String result = sb.toString();

    - **Collections:** Prefer Java Collections over arrays for their flexibility and utility. Use generics to ensure type safety.

  - ### 2.3 Anti-patterns and Code Smells

    - **God Class:** Avoid creating large classes that do too much. Break down large classes into smaller, more manageable components.
    - **Long Method:** Avoid creating long methods. Break down long methods into smaller, more focused methods.
    - **Shotgun Surgery:** Avoid making many small changes in multiple classes. This indicates a lack of cohesion and can make it difficult to maintain the code.
    - **Data Clumps:** Avoid passing the same group of data items together in multiple methods. Create a class to encapsulate the data items.
    - **Primitive Obsession:** Avoid using primitive types excessively. Create value objects to represent domain concepts.
    - **Switch Statements:** Limit use of switch statements especially with larger number of cases. Consider using polymorphism with Strategy pattern.
    - **Empty Catch Blocks:** Avoid empty catch blocks. Always handle exceptions appropriately, either by logging them, rethrowing them, or taking corrective action.

  - ### 2.4 State Management

    - **Immutability:** Prefer immutable objects whenever possible. Immutable objects are thread-safe and easier to reason about.
    - **Stateless Services:** Design services to be stateless. This improves scalability and simplifies testing.
    - **Session Management:** Use session management frameworks (e.g., Spring Session) to manage user sessions in web applications.

  - ### 2.5 Error Handling

    - **Exceptions for Exceptional Cases:** Use exceptions only for exceptional cases, not for normal control flow.
    - **Specific Exception Types:** Catch specific exception types rather than generic `Exception`. This allows you to handle different types of errors differently.
    - **Logging:** Log exceptions with sufficient context to aid debugging. Include the stack trace and any relevant data.
    - **Custom Exceptions:** Create custom exception types to represent application-specific errors.
    - **Don't Swallow Exceptions:** Never swallow exceptions without logging or handling them. It hides the exception making debugging much harder.

- ## 3. Performance Considerations

  - ### 3.1 Optimization Techniques

    - **Object Creation and Reuse:** Balance between:
      - Minimize object creation for frequently used objects (use pools or caching)
      - Allow lazy loading for rarely accessed or heavy resources
      - Use collections for dynamic data structures, arrays for fixed-size performance-critical operations
    - **Connection Pooling:** Use connection pooling to reuse database connections.
    - **Efficient Algorithms:** Choose appropriate algorithms for specific tasks.
    - **Lazy Initialization:** Use for heavy resources or rarely accessed components.

  - ### 3.2 Lazy Loading

    - **On-Demand Loading:** Load resources or components only when they are needed.
    - **Virtual Proxy:** Use a virtual proxy to delay the loading of a heavy resource until it is accessed.

- ## 4. Security Best Practices

  - ### 4.1 Common Vulnerabilities

    - **SQL Injection:** Prevent SQL injection by using parameterized queries or prepared statements. Never concatenate user input directly into SQL queries.
    - **Cross-Site Scripting (XSS):** Prevent XSS by encoding user input before displaying it in web pages.
    - **Cross-Site Request Forgery (CSRF):** Prevent CSRF by using anti-CSRF tokens.
    - **Authentication and Authorization Issues:** Implement proper authentication and authorization mechanisms to protect sensitive resources.
    - **Denial of Service (DoS):** Protect against DoS attacks by limiting request rates and implementing rate limiting.
    - **Insecure Deserialization:** Prevent insecure deserialization by avoiding deserialization of untrusted data, or using secure deserialization methods.
    - **Dependency Vulnerabilities:** Use tools like OWASP Dependency-Check to identify and mitigate vulnerabilities in third-party libraries.

  - ### 4.2 Input Validation

    - **Whitelisting:** Use whitelisting to validate input against a list of allowed values. Avoid blacklisting, as it is difficult to anticipate all possible malicious inputs.
    - **Regular Expressions:** Use regular expressions to validate input patterns (e.g., email addresses, phone numbers).
    - **Length Limits:** Enforce length limits on input fields to prevent buffer overflows.
    - **Encoding:** Encode user input to prevent XSS attacks.

  - ### 4.3 Authentication and Authorization

    - **Strong Passwords:** Enforce strong password policies (e.g., minimum length, complexity).
    - **Hashing:** Hash passwords using a strong hashing algorithm (e.g., bcrypt, Argon2) and a salt.
    - **Two-Factor Authentication (2FA):** Implement 2FA to provide an extra layer of security.
    - **Role-Based Access Control (RBAC):** Use RBAC to control access to resources based on user roles.
    - **OAuth 2.0:** Use OAuth 2.0 for delegated authorization.

  - ### 4.4 Data Protection

    - **Encryption:** Encrypt sensitive data at rest and in transit.
    - **Data Masking:** Mask sensitive data in logs and error messages.
    - **Access Control:** Restrict access to sensitive data to authorized users only.

  - ### 4.5 Secure API Communication

    - **HTTPS:** Use HTTPS for all API communication.
    - **TLS/SSL:** Configure TLS/SSL properly to ensure secure communication.
    - **API Keys:** Use API keys to authenticate API clients.
    - **Rate Limiting:** Implement rate limiting to prevent abuse of your APIs.
    - **Input Validation:** Validate all input to your APIs to prevent injection attacks.

- ## 5. Testing Approaches

  - ### 5.1 Unit Testing

    - **Testing Framework:** Use JUnit 5 for test structure and lifecycle
    - **Test Organization:** Follow Arrange-Act-Assert pattern
    - **Test Coverage:** Aim for high test coverage
    - **Independent Tests:** Write independent tests

  - ### 5.2 Mocking and Stubbing

    - **Mocking Framework:** Use Mockito as the primary mocking framework
    - **Mock Usage:**
      - Mock external dependencies and services
      - Mock complex components that are not the focus of the test
      - Use real objects for simple, self-contained classes
    - **Verify Interactions:** Verify that your code interacts with dependencies as expected
    - **Avoid Over-Mocking:** Focus on mocking only what's necessary for the test

  - ### 5.3 Validation

    - **AssertJ:** Use AssertJ for validation
    - **Use Extracting:** When validating multiple properties from an object, use extracting instead of checking individual properties
