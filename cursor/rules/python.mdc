---
description: Comprehensive guidelines for Python development, covering code organization, performance, security, testing, and more.  These rules promote maintainable, efficient, and secure Python codebases.
globs: *.py
alwaysApply: false
---
# Python Best Practices and Coding Standards

This document outlines comprehensive best practices and coding standards for Python development, aiming to promote clean, efficient, maintainable, and secure code.

## 1. Code Organization and Structure

### 1.1. File Naming Conventions

*   **Modules:**  Lowercase, with underscores for readability (e.g., `my_module.py`).
*   **Packages:** Lowercase (e.g., `my_package`). Avoid underscores unless necessary.
*   **Tests:** Start with `test_` (e.g., `test_my_module.py`).

### 1.2. Module Organization Best Practices

*   **Single Responsibility Principle:** Each module should have a well-defined purpose.
*   **Imports:**
    *   Order: standard library, third-party, local.
    *   Absolute imports are generally preferred (e.g., `from my_package.module1 import function1`).
    *   Use explicit relative imports (`from . import sibling_module`) when dealing with complex package layouts where absolute imports are overly verbose or impractical.
*   **Constants:**  Define module-level constants in uppercase (e.g., `MAX_ITERATIONS = 100`).
*   **Dunder names:** `__all__`, `__version__`, etc. should be after the module docstring but before any imports (except `from __future__`).  Use `__all__` to explicitly define the public API.

### 1.3. Component Architecture Recommendations

*   **Layered Architecture:** Suitable for larger applications, separating concerns into presentation, business logic, and data access layers.
*   **Dependency Injection:** Use dependency injection to improve testability and reduce coupling.

### 1.4. Code Splitting Strategies

*   **By Functionality:**  Split code into modules based on distinct functionalities (e.g., user management, data processing).
*   **By Layer:** Separate presentation, business logic, and data access code.
*   **Lazy Loading:** Use `importlib.import_module()` to load modules on demand, improving startup time.
*   **Conditional Imports:** Import modules only when needed, based on certain conditions.

## 2. Common Patterns and Anti-patterns

### 2.1. Design Patterns

*   **Singleton:**  Restrict instantiation of a class to one object.
*   **Factory:**  Create objects without specifying the exact class to be created.
*   **Observer:**  Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
*   **Strategy:**  Define a family of algorithms, encapsulate each one, and make them interchangeable.
*   **Decorator:**  Add responsibilities to objects dynamically.
*   **Context Manager:** Guarantees resources are properly cleaned up (e.g., files are closed).

### 2.2. Recommended Approaches for Common Tasks

*   **Data Validation:** Use libraries like `pydantic` or `marshmallow` for data validation and serialization.
*   **Configuration Management:** Use libraries like `python-decouple`, `dynaconf` or standard library's `configparser` to manage environment-specific settings.
*   **Logging:** Use the `logging` module for structured logging. Configure log levels and handlers appropriately.
*   **Command-Line Interfaces:** Use `argparse`, `click` or `typer` for creating command-line interfaces.
*   **Asynchronous Programming:** Use `asyncio` for I/O-bound and concurrency problems.

### 2.3. Anti-patterns and Code Smells

*   **God Class:** A class that does too much.  Break it down into smaller, more focused classes.
*   **Shotgun Surgery:**  Making small changes to many different classes at once. Indicates poor cohesion.
*   **Spaghetti Code:**  Unstructured and difficult-to-follow code.  Refactor using well-defined functions and classes.
*   **Duplicate Code:**  Extract common code into reusable functions or classes (DRY - Don't Repeat Yourself).
*   **Magic Numbers/Strings:**  Use named constants instead of hardcoded values.
*   **Nested Callbacks:**  Avoid excessive nesting of callbacks. Use `async/await` or promises for better readability.
*   **Premature Optimization:** Don't optimize code before identifying bottlenecks.

### 2.4. State Management Best Practices

*   **Stateless Functions:** Prefer stateless functions where possible.
*   **Immutable Data:** Use immutable data structures to prevent accidental modification.
*   **Explicit State:**  Manage state explicitly using classes or data structures.  Avoid relying on global variables.
*   **Context Variables:** Use `contextvars` (Python 3.7+) for managing request-scoped state in asynchronous applications.
*   **Redux-like patterns:** Consider redux-like patterns for managing client-side and complex application state.

### 2.5. Error Handling Patterns

*   **Specific Exceptions:** Catch specific exceptions rather than broad `Exception` or `BaseException`.
*   **`try...except...finally`:** Use `finally` to ensure cleanup code is always executed.
*   **Context Managers:**  Use context managers (`with open(...) as f:`) for resource management.
*   **Logging Errors:** Log exceptions with complete traceback information.
*   **Raising Exceptions:** Raise exceptions with informative error messages.
*   **Custom Exceptions:** Create custom exception classes for specific error conditions.
*   **Avoid using exceptions for control flow.** Exceptions should represent exceptional circumstances.

## 3. Performance Considerations

### 3.1. Optimization Techniques

*   **Efficient Data Structures:**  Choose the right data structure for the task (e.g., `set` for membership testing, `dict` for lookups).
*   **List Comprehensions and Generators:**  Use list comprehensions and generator expressions for concise and efficient code.
*   **Vectorization with NumPy:**  Use NumPy for numerical computations, leveraging vectorized operations.
*   **String Concatenation:** Use `''.join(iterable)` for efficient string concatenation.
*   **Avoid Global Variables:** Accessing local variables is faster than accessing global variables.

### 3.2. Memory Management Considerations

*   **Object References:**  Be mindful of object references and circular dependencies, which can prevent garbage collection.
*   **Slots:** Use `__slots__` in classes to reduce memory footprint (disables `__dict__`).
*   **Generators:** Use generators for processing large datasets without loading them into memory.
*   **Data type sizing:** Use the most efficient data types possible to reduce memory use.

### 3.3. Lazy Loading Strategies

*   **Module Loading:**  Use `importlib.import_module()` to load modules on demand.
*   **Data Loading:** Load large datasets only when needed.
*   **Deferred Execution:**  Use generators or coroutines to defer execution of code.

## 4. Security Best Practices

### 4.1. Common Vulnerabilities and Prevention

*   **SQL Injection:**  Use parameterized queries or ORMs to prevent SQL injection attacks.
*   **Cross-Site Scripting (XSS):** Sanitize user input and escape output to prevent XSS attacks.
*   **Cross-Site Request Forgery (CSRF):**  Use CSRF tokens to protect against CSRF attacks.
*   **Command Injection:**  Avoid executing arbitrary commands based on user input. If necessary, sanitize input carefully.
*   **Path Traversal:**  Validate file paths to prevent path traversal attacks.
*   **Denial of Service (DoS):** Implement rate limiting and input validation to protect against DoS attacks.
*   **Pickle Deserialization:**  Avoid using `pickle` to deserialize untrusted data, as it can lead to arbitrary code execution. Use safer alternatives like JSON or Protocol Buffers.
*   **Hardcoded Secrets:** Never hardcode secrets (passwords, API keys) in code. Use environment variables or secure configuration files.

### 4.2. Input Validation Best Practices

*   **Whitelisting:**  Validate input against a whitelist of allowed values.
*   **Regular Expressions:** Use regular expressions to validate input formats.
*   **Data Type Validation:**  Ensure input data types are correct.
*   **Length Validation:**  Limit the length of input strings.
*   **Sanitization:**  Remove or escape potentially harmful characters from input.
*   **Use libraries:** Use libraries like `cerberus` and `schematics` to assist with validating the input.

### 4.3. Authentication and Authorization Patterns

*   **Authentication:**
    *   Use strong password hashing algorithms (e.g., bcrypt, Argon2).
    *   Implement multi-factor authentication (MFA).
    *   Use secure session management techniques.
*   **Authorization:**
    *   Implement role-based access control (RBAC) or attribute-based access control (ABAC).
    *   Use a permissions system to control access to resources.
    *   Enforce the principle of least privilege.
    *   Use access tokens (JWTs).

### 4.4. Data Protection Strategies

*   **Encryption:** Encrypt sensitive data at rest and in transit.
*   **Data Masking:** Mask sensitive data when displaying it to users.
*   **Tokenization:** Replace sensitive data with non-sensitive tokens.

### 4.5. Secure API Communication

*   **HTTPS:**  Always use HTTPS for API communication.
*   **API Keys:**  Use API keys for authentication.
*   **OAuth 2.0:**  Use OAuth 2.0 for delegated authorization.
*   **Input validation**: Validate all API requests before processing.
*   **Rate Limiting:** Implement rate limiting to prevent abuse.

## 5. Testing Approaches

### 5.1. Unit Testing Strategies
*   **Test Individual Units:** Test individual functions, classes, or modules in isolation.
*   **Test-Driven Development (TDD):** Write tests before writing code.
*   **Coverage:**  Aim for high test coverage.
*   **Assertion Styles:** Use appropriate assertion methods (e.g., `assertEqual`, `assertTrue`, `assertRaises`).
*   **Boundary conditions:** Test boundary conditions and edge cases.
*   **Error conditions:** Test that exceptions are raised when appropriate.

### 5.2. Mocking and Stubbing Techniques

*   **`unittest.mock`:** Use the `unittest.mock` module for mocking and stubbing.
*   **Patching:**  Use `patch` to replace objects with mocks during tests.
*   **Side Effects:**  Define side effects for mocks to simulate different scenarios.
*   **Mocking External Dependencies:** Mock external dependencies like databases, APIs, and file systems.
*   **Use dependency injection for testability.** Dependency injection makes it easier to mock dependencies.

## 6. Common Pitfalls and Gotchas

### 6.1. Frequent Mistakes

*   **Mutable Default Arguments:**  Avoid using mutable default arguments in function definitions.
*   **Scope of Variables:**  Be aware of variable scope in nested functions.
*   **`==` vs. `is`:**  Use `==` for value comparison and `is` for object identity comparison.
*   **`try...except` Blocks:** Placing too much code inside try blocks. Keep try blocks as small as possible.
*   **Ignoring Exceptions:** Swallowing exceptions without handling or logging them.
*   **Incorrect indentation.**  Indentation errors are a common source of bugs.

### 6.2. Edge Cases

*   **Floating-Point Arithmetic:** Be aware of the limitations of floating-point arithmetic.
*   **Unicode Handling:** Handle Unicode strings carefully.
*   **File Encoding:**  Specify file encoding when reading and writing files.
*   **Time Zones:**  Handle time zones correctly.
*   **Resource limits:** Be aware of and handle system resource limits (e.g., file handles, memory).

## 7. Code Generation Standards

### 7.1. Type Hints and Documentation

*   **Always Include Type Hints:**
    *   Use type hints for all function parameters and return types
    *   Include Optional types when parameters can be None
    *   Use appropriate container types (list, dict, set) with their type parameters
    ```python
    def process_items(items: list[str], max_length: Optional[int] = None) -> dict[str, int]:
        return {item: len(item) for item in items if max_length is None or len(item) <= max_length}
    ```

*   **Docstring Requirements:**
    *   Every public function must have a docstring with:
        - Brief description
        - Args section with all parameters
        - Returns section
        - Raises section if applicable
    ```python
    def validate_user_data(user_dict: dict[str, Any]) -> User:
        """
        Validate and convert user dictionary to User object.

        Args:
            user_dict: Dictionary containing user data with keys:
                      'name', 'email', and 'age'

        Returns:
            User object with validated data

        Raises:
            ValidationError: If required fields are missing or invalid
        """
    ```

### 7.2. Code Structure and Formatting

*   **Consistent String Formatting:**
    *   Use f-strings for string interpolation
    *   Use raw strings for regex patterns
    *   Use triple quotes for multi-line strings
    ```python
    def generate_greeting(name: str, age: int) -> str:
        return f"Hello {name}, you are {age} years old"
    ```

*   **Clear Error Handling:**
    *   Generate try-except blocks with specific exceptions
    *   Include error messages that describe the specific failure
    *   Log errors with context information
    ```python
    try:
        processed_data = process_user_input(raw_input)
    except ValueError as e:
        logger.error(f"Invalid input format: {e}")
        raise ValidationError(f"Could not process input: {e}")
    ```

### 7.3. Function and Class Generation

*   **Function Organization:**
    *   Generate functions with single responsibility
    *   Maximum function length of 50 lines
    *   Group related functions together
    *   Place helper functions after main functions

*   **Class Structure:**
    *   Generate properties for attribute access control
    *   Include `__init__` with type-hinted parameters
    *   Implement `__str__` and `__repr__` for debugging
    ```python
    class UserProfile:
        def __init__(self, name: str, email: str) -> None:
            self._name = name
            self._email = email

        @property
        def name(self) -> str:
            return self._name

        def __str__(self) -> str:
            return f"UserProfile(name={self._name})"
    ```

### 7.4. Resource Management

*   **Context Managers:**
    *   Generate context managers for resource handling
    *   Include cleanup code in finally blocks
    ```python
    def process_file(filepath: str) -> list[str]:
        with open(filepath, 'r', encoding='utf-8') as file:
            return [line.strip() for line in file]
    ```

*   **Resource Cleanup:**
    *   Generate cleanup code for all opened resources
    *   Use try-finally blocks for complex cleanup scenarios
    *   Close connections and files explicitly

### 7.5. Generated Code Testing Support

*   **Testable Code Structure:**
    *   Generate pure functions where possible
    *   Inject dependencies rather than creating them inside functions
    *   Include parameter validation at function boundaries
    ```python
    def calculate_total(prices: list[float], tax_rate: float) -> float:
        """
        Calculate total price including tax.

        Args:
            prices: List of item prices
            tax_rate: Tax rate as decimal (e.g., 0.1 for 10%)

        Returns:
            Total price including tax

        Raises:
            ValueError: If tax_rate is negative
        """
        if tax_rate < 0:
            raise ValueError("Tax rate cannot be negative")
        subtotal = sum(prices)
        return subtotal * (1 + tax_rate)
    ```

### 7.6. Modern Python Features

*   **Pattern Matching:**
    *   Generate match-case statements for complex conditionals
    *   Include catch-all case with appropriate default behavior
    ```python
    def process_command(command: list[str]) -> str:
        match command:
            case ["create", name, *args]:
                return create_item(name, args)
            case ["delete", item_id]:
                return delete_item(item_id)
            case _:
                return "Unknown command"
    ```

*   **Async Support:**
    *   Generate async functions when dealing with I/O operations
    *   Include proper exception handling in async code
    *   Use async context managers for resource management
    ```python
    async def fetch_user_data(user_id: int) -> dict[str, Any]:
        async with aiohttp.ClientSession() as session:
            async with session.get(f"/api/users/{user_id}") as response:
                return await response.json()
    ```
